<!-- 0d4a281d-cf64-470d-aa99-77d58ff1f699 d252daa2-d0cc-4798-b292-d334f17a73de -->
# SX/DM Grid Bracket Connectors – Implementation Plan

## Scope & Alignment

- **Goal**: Visually connect SX/SXT and dual moguls finals grids with bracket-style lines between runs, using only structural HTML/CSS changes inside the grid renderer so pagination and protocol templates remain stable.
- **Current state**: `ProtocolGridBlock` in [`src/renderer/classes/Protocol/ProtocolGrid.js`](src/renderer/classes/Protocol/ProtocolGrid.js) already normalizes stages/runs via `buildGridRaces`, paginates them via `splitGridIntoPages`, and renders columns/runs with uniform flex-based blocks; SX vs DM differences are isolated inside `renderGridRun`.
- **Alignment review**: The existing plan (group-by-run-index, inline connectors per stage, no cross-page links) matches the real code: pagination slices `runs` per stage by index, `_gridLayout.extraPerRun` only affects spacing, and no other module depends on exact run-wrapper markup. We only need to localize changes to `ProtocolGrid.js`, using existing `isFinalOfDisciplines` checks and respecting current DM/SX finals detection.

## Step 1 – Add discipline helper for bracket grids

- **Introduce `isBracketDiscipline(dataCtx)`** next to `isSXFinalCompetition` in [`ProtocolGrid.js`](src/renderer/classes/Protocol/ProtocolGrid.js), implemented as:
- `const isBracketDiscipline = (dataCtx) => isFinalOfDisciplines(dataCtx, ['DM', 'SX', 'SXT']);`.
- **Usage**: Treat `dataCtx` exactly like `isSXFinalCompetition` does (final-stage competitions only), so bracket lines are rendered only for DM and SX/SXT finals grids and never for qualifications or other disciplines.

## Step 2 – Implement `groupRunsForBracket(runs)` helper

- **Add a pure helper** in [`ProtocolGrid.js`](src/renderer/classes/Protocol/ProtocolGrid.js), near `buildGridRaces`, that:
- Accepts already-sliced `runs[]` (after pagination) and returns an array of groups: `[{ runs: [runs[0], runs[1]] }, { runs: [runs[2], runs[3]] }, ...]`.
- For edge cases (odd number of runs or 1 run on a page) produces a final group with `group.runs.length === 1` without throwing; later logic will simply omit the connector for singletons.
- **Rationale**: Grouping is local to the current stage/page and does not depend on DMRounds/SXRounds metadata, so we preserve the existing index-based bracket semantics and pagination behaviour.

## Step 3 – Extend `gridBlockStyles.run` with bracket styles

- **Add `bracketGroupStyles`** under `gridBlockStyles.run` in [`ProtocolGrid.js`](src/renderer/classes/Protocol/ProtocolGrid.js):
- Core properties: `position: 'relative'`, `display: 'flex'`, `flexDirection: 'column'`, `alignItems: 'stretch'`, and no extra vertical `margin`/`padding` so measurement and `_gridLayout.extraPerRun` spacing remain valid.
- **Add `bracketConnectorStyles`** under `gridBlockStyles.run`:
- Core properties: `position: 'absolute'`, `top: '0'`, `bottom: '0'`, `right: '-1em'`, `width: '1em'`, `borderRight: '1px solid #000'`.
- Optional: `borderTop` / `borderBottom` to visually create a bracket shape (vertical line plus short horizontal stubs) while still being a single inline `<div>`; keep colors neutral so they work in both dark/light protocol themes.
- **Constraint**: Do not change existing `stageRunStyles`/`stageRunsStyles` or font sizes; connectors must be purely additive styling that does not force different heights.

## Step 4 – Introduce `renderBracketRunGroup` and refactor `renderGridStage`

- **Create `renderBracketRunGroup`** in [`ProtocolGrid.js`](src/renderer/classes/Protocol/ProtocolGrid.js) next to `renderGridRun`:
- Signature: `(dataCtx, { stage, isEvenStage, isSemiFinalStage, isFinalStage, group }, ctx) => string`.
- Implementation: map `group.runs` (1–2 items) through existing `renderGridRun(...)` and wrap the concatenated HTML in a `<div>` with `gridBlockStyles.run.bracketGroupStyles`, then append an inner `<div>` with `gridBlockStyles.run.bracketConnectorStyles` **only when `group.runs.length >= 2`**.
- **Refactor `renderGridStage`** to conditionally use grouping:
- After computing `runs` (respecting `ctx.pageSegments`), `isEvenStage`, `isSemiFinalStage`, `isFinalStage`, derive:
  - `const isBracket = isBracketDiscipline(dataCtx);`
  - `const isLastStage = index === dataCtx.races.length - 1;`
  - `const shouldShowBracket = isBracket && !isLastStage && runs.length >= 2;`.
- If `shouldShowBracket`:
  - `const grouped = groupRunsForBracket(runs);`
  - Render `grouped.map((group) => renderBracketRunGroup(dataCtx, { stage, isEvenStage, isSemiFinalStage, isFinalStage, group }, ctx)).join('')` inside the existing `stageRunsComputedStyles` container.
- Else (non-bracket or final stage): keep the current behaviour `runs.map((run) => renderGridRun(...)).join('')` unchanged.
- **Guarantees**: This keeps the stage header/title markup and `stageRunsComputedStyles` container identical, only substituting the inner run-list structure for bracket stages.

## Step 5 – Ensure pagination and layout invariants are preserved

- **Page-local grouping**: Because `renderGridStage` already slices `stage.runs` with `ctx.pageSegments[index]`, `groupRunsForBracket` operates only on per-page runs, so connectors can never cross page boundaries; each page simply shows connectors between the runs that appear on that page.
- **Interaction with `_gridLayout.extraPerRun`**: Leave `extraPerRun` handling in `renderGridRun` as-is; grouping does not change per-run wrappers, so the total height per group is the sum of existing run heights plus any small relative-positioned connector (which does not add to layout height).
- **Final/semi-final anchoring**: `splitGridIntoPages` keeps semi-final and final stages fully on the first page; by guarding on `!isLastStage`, we avoid drawing outgoing connectors from the final stage while still rendering its runs normally and preserving the `renderCompetitionTop` winners overlay.

## Step 6 – Visual tuning and safety checks

- **Connector placement**: Manually verify in the preview (`components/protocol/protocolBuilder/preview.vue`) that `right: '-1em'` and column `marginLeft: '2em'` in `stageComputedStyles` produce visually pleasing spacing between stages; adjust connector width/margins if they clash with stage titles or the winners overlay.
- **SX vs DM specifics**: Confirm that both DM brackets (using `race.runs`) and SX/SXT finals (using `stage.heats` normalized by `buildGridRaces`) produce the expected 2-run groups per stage; no extra SX-specific branching is needed because `renderGridRun` already handles SX grid layout via `isSXFinalGrid`.
- **Graceful degradation**: In events with irregular grids (manual edits or incomplete brackets) where run counts are odd or stages missing, grouping must still render all runs without throwing; singleton groups simply show no connector, yielding an unconnected but readable grid.

## Step 7 – Testing strategy

- **DM finals grids**: Use a multi-stage dual moguls event (with all standard rounds) and grid-enabled templates to check that:
- Bracket lines appear only for non-final stages, always between correct run pairs, and do not cross page breaks when the grid is paginated.
- **SX/SXT finals grids**: Use a 32-competitor SX finals event (1/8 → 1/4 → 1/2 → big/small final) and confirm connectors pair heats correctly per stage and visually resemble FIS PDFs while respecting our fonts and Russian labels.
- **Edge cases**: Verify events with only finals (no earlier rounds) and partially-filled grids; ensure the grid still renders and that connectors are either fully omitted or limited to pairs that exist on each page, without affecting other protocol blocks or export flows.

### To-dos

- [ ] Confirm current `ProtocolGridBlock` render/pagination behaviour and run markup in `src/renderer/classes/Protocol/ProtocolGrid.js` to identify safe insertion points for bracket grouping.
- [ ] Add `isBracketDiscipline(dataCtx)` helper in `ProtocolGrid.js` using `isFinalOfDisciplines(dataCtx, ['DM', 'SX', 'SXT'])` to scope bracket rendering to DM and SX/SXT finals.
- [ ] Implement `groupRunsForBracket(runs)` in `ProtocolGrid.js` to pair runs by index and handle odd/singleton cases without throwing.
- [ ] Extend `gridBlockStyles.run` in `ProtocolGrid.js` with `bracketGroupStyles` and `bracketConnectorStyles` that are layout-neutral and use absolute positioning for connector lines.
- [ ] Refactor `renderGridStage` in `ProtocolGrid.js` to optionally use `renderBracketRunGroup` for non-final DM/SX/SXT stages after pagination, preserving existing behaviour for other stages and disciplines.
- [ ] Manually test DM and SX/SXT finals grids in the protocols builder preview with single-page and multi-page layouts to verify connector alignment, page-local behaviour, and absence of regressions.