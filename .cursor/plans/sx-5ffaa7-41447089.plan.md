<!-- 41447089-0f6e-4565-a643-70c00ffdd5fe d2b656d9-cf42-496f-beeb-ac1af5e89e66 -->
# SX/DM Grid Connection Lines – Implementation Plan

### 1. Feasibility & Constraints

- **Feasibility**: The current grid renderer in [`src/renderer/classes/Protocol/ProtocolGrid.js`](src/renderer/classes/Protocol/ProtocolGrid.js) already produces a stable, flex-based column layout with uniform run blocks (thanks to `gridBlockStyles` and `_gridLayout.extraPerRun`). This makes it feasible to draw approximate bracket lines purely via additional HTML/CSS without runtime DOM measurements.
- **Constraints**:
  - Protocols render as static HTML strings; we cannot rely on interactive JS post-processing for layout, so any solution must be *layout-structural* rather than coordinate-driven.
  - Pagination (`splitGridIntoPages`) slices runs per stage by index; connectors **must not** cross page boundaries and must degrade gracefully when only some runs of a stage appear on a given page.
  - The bracket topology for DM and SX is regular (power-of-two run counts per stage), so we can infer winner flows by **run index grouping** instead of storing explicit graph links.

### 2. High-level Approach

- **Chosen approach**: Add **inline bracket connectors inside each stage column**, grouping runs in pairs and drawing vertical + short horizontal lines that visually connect them toward the next stage, similar to the FIS example. Connectors will:
  - Be implemented as additional `<div>` elements or pseudo-"cells" *within the stage column*, not as global SVG overlays.
  - For each *non-final* stage, group runs `[0,1]`, `[2,3]`, etc., and draw a bracket shape at the right edge of each group.
  - Optionally extend slightly into the gap toward the next stage using negative margins so the bracket visually spans between columns.
- **Disciplines covered**:
  - Dual moguls (DM) and SX/SXT finals grids rendered via `ProtocolGridBlock` (where `buildGridRaces` is active) are the only targets.
  - Other disciplines or non-bracket grids remain untouched.
- **Justification vs alternatives**:
  - Compared to an **SVG/absolute-position** overlay, this approach stays localized inside `ProtocolGrid.js`, respects pagination, and avoids complex coordinate math while still producing clear bracket visuals.
  - Compared to doing nothing, it gives judges and operators a visual mapping similar to FIS PDFs, with bounded implementation risk.

### 3. Data Model & Grouping Logic

- **Re-use existing normalisation**:
  - Leverage `buildGridRaces(dataCtx)` in [`ProtocolGrid.js`](src/renderer/classes/Protocol/ProtocolGrid.js) which already provides stage objects with `runs[]` for both DM and SX finals.
- **New helper**: `isBracketDiscipline(dataCtx)`
  - Implement a small helper near `isSXFinalCompetition`:
    - `const isBracketDiscipline = (dataCtx) => isFinalOfDisciplines(dataCtx, ['DM', 'SX', 'SXT']);`.
  - This ensures we only compute connectors for disciplines where bracket semantics are expected.
- **Run grouping helper**: `groupRunsForBracket(runs)`
  - Add a pure helper in `ProtocolGrid.js`:
    - Input: `runs[]` array (already page-sliced when called from `renderGridStage`).
    - Output: `[{ runs: [run0, run1] }, { runs: [run2, run3] }, ...]`.
    - If the run count is odd or 1 (edge case), the final group will simply contain a single run and will draw either no connector, or a degenerate one.
  - This grouping is local to stage columns; we do not need explicit next-stage references, only the visual pairing.

### 4. Markup Changes in `renderGridStage` / `renderGridRun`

- **Current structure** (simplified):
  - Stage wrapper:
    - Stage title (`stage.title`).
    - Runs container: `runs.map((run) => renderGridRun(...))`.
- **Target structure for bracket stages**:
  - For stages where `isBracketDiscipline(dataCtx)` is true and `!isFinalStage`:
    - Compute grouped runs: `const grouped = groupRunsForBracket(runs);`.
    - Render each group as a wrapper containing one or two runs plus a connector cell, e.g.:
      ```js
      const renderGridStage = (...) => {
        ...
        const shouldShowBracket = isBracketDiscipline(dataCtx) && !isFinalStage;
      
        const renderedRuns = shouldShowBracket
          ? grouped.map((group) => renderBracketRunGroup(dataCtx, { stage, isEvenStage, isSemiFinalStage, isFinalStage, group }, ctx)).join('')
          : runs.map((run) => renderGridRun(dataCtx, { stage, isEvenStage, isSemiFinalStage, isFinalStage, run }, ctx)).join('');
      ```

  - **New helper** `renderBracketRunGroup` in `ProtocolGrid.js`:
    - Accepts `group.runs` (1 or 2 runs) and delegates to `renderGridRun` for each run.
    - Wraps them into a `div` with `runGroupStyles`, plus an inner `div` (or pseudo element) for the connector line.
    - Example snippet:
      ```js
      const renderBracketRunGroup = (dataCtx, { stage, isEvenStage, isSemiFinalStage, isFinalStage, group }, ctx) => {
        const renderedRuns = group.runs
          .map((run) => renderGridRun(dataCtx, { stage, isEvenStage, isSemiFinalStage, isFinalStage, run }, ctx))
          .join('');
      
        return `
          <div style="${ctx.stylesToCSS(gridBlockStyles.run.bracketGroupStyles)}">
            ${renderedRuns}
            <div style="${ctx.stylesToCSS(gridBlockStyles.run.bracketConnectorStyles)}"></div>
          </div>
        `;
      };
      ```

- **Non-bracket & final stages**:
  - Continue to render `runs.map(renderGridRun)` exactly as today; no grouping or connectors.
- **SX vs DM**:
  - `renderGridRun` already branches between SX and DM per run (`isSXFinalGrid` vs not). Grouping logic is agnostic; DM/SX differences remain entirely inside `renderGridRun`.

### 5. Styling & Visual Design

- **New styles in `gridBlockStyles.run`** in `ProtocolGrid.js`:
  - `bracketGroupStyles`:
    - `position: 'relative'`, `display: 'flex'`, `flexDirection: 'column'`, `alignItems: 'stretch'`, optional vertical padding.
  - `bracketConnectorStyles`:
    - `position: 'absolute'`, `top: '0'`, `bottom: '0'`, `right: '-1em'` (to extend slightly into inter-stage gap),
    - `width: '1em'`, `borderRight: '1px solid #000'`,
    - optional `borderTop` / `borderBottom` segments so that the line visually starts near the middle of the top run and ends near the middle of the bottom run.
- **Consistent heights**:
  - Because each run uses `run.stageRunStyles` plus the existing `_gridLayout.extraPerRun` spacing, their heights are effectively uniform; grouping two runs and attaching a vertically stretched connector inside `bracketGroupStyles` will align nicely.
  - `shrink-cell` and `whiteSpace: 'nowrap'` on names already minimise variable row height, which is important for visual consistency.
- **Pagination compatibility**:
  - On pages where only one of a pair’s runs is present (e.g. last page slices odd number of runs):
    - `groupRunsForBracket` will output a group with a single run; we can choose to either:
      - Draw only a short horizontal connector from that run towards the right, or
      - Suppress the connector for singletons (simpler and safer).

### 6. Discipline & Stage Guards

- **Where to enable connectors**:
  - In `renderGridStage`, compute flags:
    - `const isBracket = isBracketDiscipline(dataCtx);`
    - `const isLastStage = index === dataCtx.races.length - 1;`
  - Only call `renderBracketRunGroup` when `isBracket && !isLastStage && runs.length >= 2`.
- **SX specifics**:
  - For SX, we likely want connectors between:
    - 1/8 → 1/4 → 1/2 → finals.
  - Since `buildGridRaces` has already normalised races per stage and our run count per stage is a multiple-of-two, the same grouping logic as DM works; we do **not** need SX-specific branching for the connectors themselves.

### 7. Testing & Validation Strategy

- **Unit-ish manual checks in `/protocols-page`**:
  - Use a DMO event with several rounds; for each grid-enabled template:
    - Confirm that connectors appear between all non-final stages and that runs group logically (pairs of two) matching the bracket semantics.
    - Check both single-page and multi-page grids to ensure connectors **do not cross page boundaries** and that the last page remains visually coherent.
  - Use an SX finals event shaped similarly to the FIS example (32 competitors, 1/8 → 1/4 → 1/2 → finals):
    - Validate that connectors visually mimic the FIS PDF: 1/8 heats paired into quarterfinals, quarterfinals into semis, semis into big/small finals.
    - Ensure connectors look acceptable under Russian labels and our current typefaces.
- **Edge cases**:
  - Stages with unexpected run counts (e.g. manual edits or partial brackets): verify that grouping logic doesn’t crash and that at worst we show isolated runs without connectors.
  - SX/DM competitions with fewer stages (e.g. only finals) should simply render grids without any connectors.

### 8. Future Enhancements (Optional, Not in First Iteration)

- Consider an **SVG-based overlay** in a separate module (e.g. `ProtocolBracketOverlay`) if we later need pixel-perfect FIS-level styling, with careful attention to:
  - Measuring run block positions inside `measureBlockHeight`’s container.
  - Emitting `<svg>` paths instead of div borders.
- Add template-level toggles (e.g. block style flag `showBracketLines: true/false`) so operators can choose between clean grids and fully decorated brackets.

### To-dos

- [ ] Review and document current grid stage/run markup and pagination behaviour in ProtocolGrid.js to confirm safe insertion points for bracket groups and connectors
- [ ] Introduce isBracketDiscipline and groupRunsForBracket helpers in ProtocolGrid.js and validate them against DM and SX finals events
- [ ] Refactor renderGridStage to optionally use a new renderBracketRunGroup helper that wraps runs in groups and injects connector markup before delegating to renderGridRun
- [ ] Extend gridBlockStyles.run with bracketGroupStyles and bracketConnectorStyles to draw vertical and short horizontal lines between grouped runs and toward the next stage
- [ ] Guard bracket rendering to DM and SX/SXT finals only and skip final stages where no outgoing connections exist
- [ ] Manually test DM and SX grids in /protocols-page with multi-page brackets to verify connector alignment, stage consistency across pages, and absence of visual regressions