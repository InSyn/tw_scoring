<!-- 383fba37-3975-4bf7-bb03-48e30878cca6 f3a86935-12eb-49ef-80e7-622f6e5c8817 -->
# TW Scoring Project Structure Map Plan

## 1. Goals, Scope, and Constraints

- **Goal**: Produce a precise, maintainable "project map" (starting at `.cursor/project-structure.md`) that reflects the **actual** TW Scoring codebase: domains, modules, processes, data flows, and key files.
- **Scope**: Entire app, including **Electron main process**, **renderer (Vue/Vuetify/Vuex)**, **Socket.IO/TCP/UDP/timer services**, **persistence (`events/`, exports)**, and **supporting utilities/config**.
- **Constraints**:
- Each context document must be **≤ 200–250 LOC**; use multiple linked files rather than a single monolith.
- Documents must be **navigable** (clear headings, links) and **stable** (resilient to small refactors).

## 2. Overall Documentation Structure

- **2.1 Primary index document**
- Create `.cursor/project-structure.md` as the **entrypoint** containing:
  - High-level overview of the application (processes, major domains).
  - Table of contents with links to per-domain sub-docs.
  - Short legend for naming conventions and path notation.
- **2.2 Per-domain sub-docs (proposed layout)**
- `.cursor/docs/structure-main-and-bootstrap.md` – Electron main process, startup flow, licensing, Socket.IO server, mobile server.
- `.cursor/docs/structure-renderer-shell-and-routing.md` – `App.vue`, layout components, router, navigation flows.
- `.cursor/docs/structure-state-and-domain-models.md` – Vuex modules + domain classes in `src/renderer/classes`.
- `.cursor/docs/structure-real-time-and-io.md` – Socket.IO client/server, TCP judge terminals, UDP server (if used), timing device TCP client, mobile server, live services.
- `.cursor/docs/structure-protocols-and-exports.md` – protocol builder, protocol templates, exports (PDF/CSV/Excel/XML), FIS XML.
- `.cursor/docs/structure-data-and-persistence.md` – `events/` files, import/export, auto-save, license files, app assets.
- `.cursor/docs/structure-logging-and-diagnostics.md` – `logger-override`, `message_system`, server messages, info messages, health indicators.
- **2.3 Cross-references**
- In each sub-doc, cross-link back to the index and to related domains (e.g. timing ↔ scoring, protocols ↔ domain models) without duplicating full explanations.

## 3. High-Level Inventory & Sanity Check

- **3.1 Root-level overview**
- Enumerate key root folders and files: `src/main/`, `src/renderer/`, `events/`, `app_assets/`, `build/`, `dist/`, `static/`, `temp_assets/`, `timing_page.html`, project-level config (`package.json`, `builder.config.json`, `jsconfig.json`, `yarn.lock`/`package-lock.json`).
- For each, capture **role sentence** (1–2 lines), e.g. "`src/main/`: Electron main process, servers, IPC handlers".
- **3.2 Entry points**
- Confirm and record:
  - Main process entry (`src/main/index.js`, `src/main/index.dev.js`).
  - Renderer entry (`src/renderer/main.js`, `src/renderer/App.vue`).
  - Build and run commands from `package.json`.
- Note how dist (`dist/electron`) maps back to `src/` sources for clarity.

## 4. Electron Main Process & Servers Mapping

- **4.1 Electron bootstrap & IPC**
- Trace `src/main/index.js`:
  - Window creation, `winURL` branching, `webPreferences` (nodeIntegration, etc.).
  - IPC handlers (`get-sys-data`, `get-build-version`), and exports (`sendServerMessage`, `sendInfoMessage`, `sendTerminalsMessage`).
  - Imported submodules: `lic_server`, `socket_setup`, `timingDeviceServerSetup`, `mobileServerSetup`.
- Document: which channels are used by renderer and what data shapes they carry.
- **4.2 Licensing server** (`src/main/lic_server.js`)
- Map IPC channels (`save-key`, `check-key`) and file paths (`app_assets/license.json` in main vs packaged app assets).
- Document how licensing state flows into the renderer (`key` Vuex module, `licCheck` component).
- **4.3 Socket.IO server and competition state** (`src/main/socket_setup.js`, `src/main/server_competition.js`)
- Describe server configuration and lifecycle (listen, error handling, `start-socket-server`/`close-server`).
- Map event contracts: `competition_data_updated`, `set_competition_data`, `judge_in`, `chief_judge_in`, `set_mark`, `set_raceStatus`, `accept_res`, `force_disconnect`, etc.
- Explain canonical `competition` object (structure of `server_competition.js`) and how it mirrors renderer `EventClass`.
- **4.4 TCP/UDP/Timing/Mobile servers**
- TCP judge terminals: `TCPServer/tcpServerSetup.js`, `terminalTCPMessageHandlers.js`, `terminalTCPMessageTransmitters.js`.
- UDP server: `UDPServer/*` – note which parts are active vs legacy.
- Timing device TCP client: `timingServer/timingDeviceServerSetup.js`.
- Mobile server: `mobileServer/mobileServerSetup.js` (HTTP/Socket.IO for mobile/live clients).
- For each, record:
  - Port/config defaults.
  - Message/command types and high-level protocols.
  - IPC channels into renderer.

## 5. Renderer Shell, Routing, and Layout

- **5.1 Renderer bootstrap**
- Map `src/renderer/main.js`:
  - Vuetify setup, Vuex store, router, global directives, `logger-override`, `initSavingStorages`.
  - Note global side-effects (e.g. console override, Electron integration via `vue-electron`).
- **5.2 App shell** (`App.vue`)
- Document the composition: `app-header`, `app-menu`, central `router-view`, `InfoMessagesContainer`, `app-footer`, `TimingDeviceSettings`, `LangSelector`, etc.
- Clarify how it wires to store (`main`, `localization`, `terminalsUdpService`).
- **5.3 Routing** (`src/renderer/router/index.js`)
- List all routes and map them to modules/pages: `competition_settings`, `competitors`, `teams`, `races-list`, `scoring`, `protocols`, `protocols-page`, `jump_codes`, `rules_setup`, `lic_check`, `main`.
- Document route guards (licence gate) and default redirects.
- **5.4 Layout components** (`components/layout/*`)
- For each (`app-header`, `app-menu`, `app-footer`):
  - Summarise their concerns (menu visibility, event save/load, theme toggle, timing panel, live services panel, language selector).
  - Identify any domain logic that might better live in Vuex or domain classes (for future refactors, but keep doc descriptive, not prescriptive).

## 6. State & Domain Model Mapping

- **6.1 Vuex store overview** (`src/renderer/store/index.js`, `modules/*`)
- For each module (`main`, `timing`, `terminalsUdpService`, `message_system`, `protocols`, `protocol_settings`, `scoring_services`, `aerials`, `moguls`, `skiCross`, `skiRamps`, `localization`, `key`):
  - Document: purpose, key state fields, main getters, important actions/mutations.
  - Note cross-module dependencies (e.g. `timing` relying on `main/competition`).
- **6.2 Domain classes** (`src/renderer/classes/*`)
- For each (`EventClass`, `RaceClass`, `CompetitorClass`, `JudgeClass`, `JuryClass`, `MarkClass`, `TimerClass`, `TeamClass`, `DM/*`, `SX/*`, `Protocol/*`, `ProtocolDataFieldClass`, `CompetitionLogMessageClass`, `EventBus`):
  - Summarise responsibility and how it connects to Vuex modules and components.
  - Record important invariants (e.g. how races reference competitors, how marks are attached, how timers map to runs/channels).
- **6.3 State flow examples**
- Choose a few representative flows and document them end-to-end:
  - Example A: judge mark from TCP terminal → main TCP server → IPC → `terminalsUdpService` → scoring components → `main/updateEvent` → Socket.IO broadcast.
  - Example B: timing event from hardware timer → `timingDeviceServerSetup` → IPC `newTime` → `timing` module + `TimerClass` → scoring UI.
  - Example C: event save/load (`save_event`/`load_event`) → `events/*.twe`.

## 7. Real-time & I/O Map

- **7.1 Socket.IO client in renderer** (`main/connect_socket` mutation, `opened_sockets`, `serverStatusChecker`)
- Document how the client connects to configured server IP/port, what events it listens to, and how it updates Vuex state.
- **7.2 Terminals & timing IPC**
- Map IPC channels: `new-judge-mark`, `result-accepted`, `echo-response`, `newTime`, `updateConnectedDevices`, `SyncTimeTCP`, `PrintTCPMessage`, `StartTCPSocket`, `DisconnectTCPSocket`.
- Record how these channels connect to `terminalsUdpService`, `timing`, and domain classes.
- **7.3 Mobile/live services**
- Sketch mobile server endpoints and any additional Socket.IO namespaces/rooms for live results.
- Note how `scoring_services` and `live_config` in `main` influence outbound updates.

## 8. Protocols, Exports, and Persistence

- **8.1 Protocol builder & templates**
- Map `src/renderer/components/protocol*`, `protocolHandlers/`, `configs/protocol-builder-config.js`, and `classes/Protocol/*`.
- Document how protocol fields are defined (handlers, cell params) and how they pull from domain data (`competition`, `competitors`, `races`).
- **8.2 Export/import flows**
- Record where and how exports are performed:
  - PDF/HTML (`html2pdf.js`, `pdf-creator-node`, `protocols.vue` / `protocols-page`).
  - CSV/JSON (`main/exportCSV`, `exportTXT`).
  - Excel import (`read-excel-file`, competitor import components).
  - XML FIS export (`main/xml_export`).
- Detail the structure of `events/*.twe` and how `save_event` / `load_event` serialize/deserialize competitions.

## 9. Logging, Messages, and Diagnostics

- **9.1 Logger override & EventBus**
- Document `logger-override.js` behaviour and `EventBus` usage.
- Show how console calls propagate into `message_system/competitionLog` and `infoMessages`.
- **9.2 Server messages**
- Map `sendServerMessage` → `server-message` IPC → `main/pushServerMessage` → UI console.
- **9.3 Health indicators**
- Record where `serverStatus`, `opened_sockets`, `connectedTerminals`, `connectedDevices` are surfaced in the UI.
- Note any periodic checks and how they are implemented (e.g. server status timers, TCP cmdCheck).

## 10. Document Authoring Strategy (Style & Maintenance)

- **10.1 Style and size discipline**
- Keep each doc **≤ 200–250 LOC** with:
  - concise sections
  - bullet-point summaries for each module/file
  - only short, high-signal code/path snippets where needed.
- **10.2 Cross-linking and discoverability**
- Use consistent headings ("Overview", "Key Files", "Data Flow") across docs.
- Ensure every important domain or file is reachable from the main index in ≤2 clicks.
- **10.3 Maintenance process**
- For any new module or major feature:
  - update the relevant sub-doc(s) in the same PR as code changes.
  - keep a short "Changelog" bullet list at the bottom of each structure doc (with date + one-line description).
- Periodically (e.g. per release), scan for drift between docs and code (missing modules, renamed files, new routes) and update the map.

## 11. Execution Order for Next Session

- **Step 1**: Finalise document filenames/sections (minor adjustments allowed to the proposed list).
- **Step 2**: Populate `.cursor/project-structure.md` with the high-level overview and table of contents.
- **Step 3**: Work top-down in this order: main process & servers → renderer shell & routing → state & domain models → real-time & I/O → protocols/exports/persistence → logging/diagnostics.
- **Step 4**: After each sub-doc is drafted, quickly re-scan the corresponding code areas to ensure no major module/file was missed.
- **Step 5**: Perform a final pass from a "new contributor" perspective: verify that following the index and sub-docs gives a coherent mental model of the whole system without diving into code.

### To-dos

- [ ] Confirm and, if needed, adjust the proposed set of project-structure documents under .cursor/ (index + per-domain sub-docs).
- [ ] Perform a root-level inventory and map main and renderer entrypoints, recording one-line roles for each major folder/file.
- [ ] Analyse Electron main process, licensing, Socket.IO server, TCP/UDP/timing/mobile servers, and document their responsibilities and IPC/event contracts.
- [ ] Document App shell, layout components, and routing structure, including licence guard and page responsibilities.
- [ ] Catalogue Vuex modules and domain classes, describing their responsibilities, key state fields, and cross-module relationships.
- [ ] Trace real-time flows (Socket.IO, terminals, timing, mobile/live) from I/O to UI, and document all key channels and handlers.
- [ ] Document protocol builder/templates, export/import flows, and the structure of events/.twe data and other persisted artefacts.
- [ ] Document logging/diagnostics paths (logger-override, message_system, server messages, health indicators) and how they tie into the UI.
- [ ] Write and refine all project-structure docs with consistent style, cross-links, and size limits, then perform a final coherence pass from a new-contributor perspective.