<!-- 840c71dc-6e2b-47a0-954f-9e534810a961 6ab0ed74-f54f-4e25-a097-997f364ce89c -->
# SX Finals Protocol Grid Adaptation

## 1. Context and Current Behaviour

- **DMO grid (what works today)**
- New protocol builder uses `ProtocolDocument` and `ProtocolGridBlock` to render dual-moguls brackets based on the active competition from [`src/renderer/store/modules/main.js`](src/renderer/store/modules/main.js) via `getDataCtx`.
- For DMO finals, `competition.races` holds `RoundClass` instances with a `runs[]` array of `DMRunClass` objects (`competitors[2]`, `results[2]`, `blueCourse`, `redCourse`) as defined in [`src/renderer/classes/DM/DMRunClass.js`](src/renderer/classes/DM/DMRunClass.js) and [`src/renderer/classes/DM/RoundClass.js`](src/renderer/classes/DM/RoundClass.js).
- `ProtocolGridBlock.render` in [`src/renderer/classes/Protocol/ProtocolGrid.js`](src/renderer/classes/Protocol/ProtocolGrid.js) assumes this DMO shape: it reads `gridData.races[*].runs`, renders each run with two competitors (blue/red), and pulls marks and scores from `CompetitorClass.marks`/`results` for the matching race.
- Pagination is fully dynamic: `splitGridIntoPages` measures grid height and slices `stage.runs` across up to four pages while keeping semi-finals and finals on the first page.
- A small “winners overlay” in `renderCompetitionTop` uses `getDMProgressionData({ onlyFinals: true })` from [`src/renderer/protocolHandlers/tableHandlers.js`](src/renderer/protocolHandlers/tableHandlers.js) to show final rankings on top of the bracket.

- **SX competitions and finals (current data & UI)**
- SX disciplines are identified via `checkCompetitionDiscipline(competition, ['SX', 'SXT'])` and stage type helpers in [`src/renderer/data/sports.js`](src/renderer/data/sports.js); `SXRounds` constants in [`src/renderer/classes/RaceClass.js`](src/renderer/classes/RaceClass.js) describe the bracket structure (1/128 → final) similarly to `DMRounds`.
- Each SX finals race is a plain `RaceClass` with a `heats[]` array of `SXHeatClass` objects (`competitors = ['', '', '', '']`, `results = ['', '', '', '']`) from [`src/renderer/classes/SX/SXHeatClass.js`](src/renderer/classes/SX/SXHeatClass.js).
- Finals UI is built around these heats:
- Race setup in [`src/renderer/components/raceList/SX/heats.vue`](src/renderer/components/raceList/SX/heats.vue) and `heat-item.vue` lets the operator manage heats and assign bibs.
- Scoring UI (`sx-heats-grid.vue`, `sx-heat-item.vue`, `sx-heat-competitor-item.vue`, `sx-heat-controls.vue`) displays heats as a grid, colours lanes with `heatColors`/`getHeatCompetitorColor` from [`src/renderer/utils/competition-utils.js`](src/renderer/utils/competition-utils.js), and stores lane results (1–4, DNS, DNF, DSQ, RAL) in `heat.results[idx]`.
- SX qualification logic is more complex and time-based (`SxQualificationScoring.vue`, `EventClass.getRaceResult`/`calculateOverallResult` for SX), but SX finals grids are purely lane-based and depend only on `heats[].competitors` + `heats[].results`.
- Legacy protocols use a separate, non-builder component `[src/renderer/components/protocols[old]/disciplines-spec/SXFinalGrid.vue](src/renderer/components/protocols[old]/disciplines-spec/SXFinalGrid.vue)` which:
- Maps `competition.races[*].heats` into rounds and heats, then renders simple tables with 4 competitors per heat.
- Contains a very rough `calculatePagination` stub (height = heats × constant) and does not reuse the new measurement-based pagination.
- Live translation already has a clean SX heats representation via `getSXHeats(competition)` in [`src/renderer/utils/fileTranslation/SX.js`](src/renderer/utils/fileTranslation/SX.js), combining lane colours, competitor identity, and `heat.results[idx]`.

- **Key structural differences between DMO grid data and SX finals**
- **Stage container**: DMO uses `races[*].runs[]` with competitor objects; SX finals use `races[*].heats[] `with competitor IDs and parallel `results[]` arrays.
- **Per-lane data**: DMO pulls marks and numeric scores from `athlete.marks`/`athlete.results` per race; SX finals only need placement/status (1–4, DNS, etc.) from each heat’s `results[]` plus the athlete’s identity.
- **Lane count & colours**: DMO has 2 lanes (blue/red), while SX uses 4 lanes with fixed colour order (`['red', 'green', 'blue', 'yellow']`).
- **Current protocol integration**: The new protocol builder and grid block know nothing about SX; SX finals only print through the legacy protocols UI.

## 2. Design Direction and Options

- **Option A – Generalise `ProtocolGridBlock` to support both DMO and SX (recommended)**
- Introduce an internal data-normalisation layer inside `ProtocolGridBlock` / `splitGridIntoPages` that derives a common `racesForGrid[]` structure from the active competition:
- For DMO finals: `racesForGrid` is essentially `competition.races` with `runs[]` as-is.
- For SX finals: `racesForGrid` is derived from `competition.races[*].heats[]`, mapping each `SXHeatClass` to a `run`-like object with `id`, `title`, `competitors[]` (resolved `CompetitorClass` objects via `getCompetitorById`), and `results[]`.
- Extend rendering logic (`renderRunCompetitor`, small parts of `renderGridRun` and competition-top overlay) to branch based on discipline (DM vs SX) or data shape (2 vs 4 lanes), but keep pagination and stage layout shared.
- Pros: single, well-tested pagination engine for both disciplines; less duplication; easier to keep SX and DMO grids visually consistent; easier future adjustments (margins, fonts, shrinking).
- Cons: `ProtocolGridBlock` becomes more complex and discipline-aware; requires careful guards so DMO behaviour is 100% preserved.

- **Option B – New SX-specific grid block or dedicated protocol type**
- Create a new `SXProtocolGridBlock` class and a separate block type in `restoreProtocolBlocks`/builder config, specialised for SX heats.
- Pros: cleaner separation between DMO and SX; less branching inside one class.
- Cons: more moving parts in the protocol builder, duplicated pagination/rendering logic, and higher maintenance cost; UX for template authors becomes more complex (two different grid block types).

- **Chosen approach**
- **Go with Option A** but keep the SX-specific logic encapsulated in a few small helpers inside `ProtocolGrid.js` and, if needed, one SX-focused utility in `fileTranslation/SX.js` or `competition-utils.js`.
- Keep pagination and stage layout entirely discipline-agnostic; only the per-run/per-competitor rendering and the optional winners overlay differ.

## 3. Planned Implementation Steps

- **Step 1 – Add a discipline-aware grid data normaliser**
- Implement a helper inside [`src/renderer/classes/Protocol/ProtocolGrid.js`](src/renderer/classes/Protocol/ProtocolGrid.js) such as `buildGridRaces(dataCtx)` that returns an array of `{ id, title, runs[] }`:
- Detect SX finals via `isFinalOfDisciplines(dataCtx, ['SX', 'SXT'])` (imported from [`src/renderer/data/sports.js`](src/renderer/data/sports.js)) or by checking for `races[*].heats`.
- For SX finals, map each `RaceClass` (`stage`) to `{ id: stage.id, title: stage.title, runs: stage.heats.map((heat, idx) => ({ id: heat.id, title: heat.title || `${stage.title}-${idx+1}`, competitors: heat.competitors, results: heat.results || [] })) }`.
- For all other disciplines, including DMO, return a shallow copy of `dataCtx.races` (or adapt `runs`/`heats` if needed, but without mutating Vuex state).
- Update `splitGridIntoPages` to use `const races = buildGridRaces(dataCtx);` instead of direct `dataCtx.races`, and compute `stageMeta`/`stagesWithRuns` from this normalised `races` array while keeping all existing pagination maths intact.

- **Step 2 – Use normalised races during grid rendering**
- In `ProtocolGridBlock.render`, derive `const races = buildGridRaces(gridData);` and use this array for:
- Computing `runsPerStage` and `totalRuns`.
- Rendering stages: `const renderedStages = races.map((stage, index) => renderGridStage({ ...gridData, races }, { stage, index }, this)).join('');` so `renderGridStage` always sees a `dataCtx` whose `races` match the normalised structure.
- Ensure the measuring helper `measureGridHeightIgnoringExplicitHeight` does not depend on the original `competition.races` shape beyond what `render()` already handles (normalisation will be applied when `measureBlockHeight` calls `block.render(dataCtx)`).

- **Step 3 – Extend per-competitor rendering for SX heats**
- Refactor `renderRunCompetitor` and, if necessary, `renderGridRun` to be discipline-aware while preserving DMO behaviour:
- Detect SX finals with the same helper as in Step 1 (either by `isFinalOfDisciplines` or by `run.competitors` being scalar IDs instead of objects and `run.results.length === 4`).
- For **DMO** (current behaviour): keep the existing logic: two lanes (blue/red), bib cell coloured via `--athlete-blue`/`--athlete-red`, 5 judge marks from `athlete.marks`, and race score/status from `athlete.results` filtered by `race_id`.
- For **SX finals**:
- Resolve the athlete object with `getCompetitorById(dataCtx, run.competitors[index]) `instead of expecting an embedded `CompetitorClass`.
- Use `heatColors`/`getHeatCompetitorColor(index+1)` for lane colouring and show bib + name similarly to `sx-heat-controls.vue` and `sx-heat-competitor-item.vue`.
- Render the **result** cell from `run.results[index] `(1–4, DNS, DNF, DSQ, RAL) with sensible formatting, falling back to `'-'` when empty.
- Drop per-judge marks for SX (or show a single time/score if later you decide to support time-based SX finals) to keep the protocol clean and closer to the official sample.
- Verify that `gridBlockStyles` for competitor rows still produce reasonable spacing with four stacked rows and that `shrink-cell` font shrinking continues to work for long names.

- **Step 4 – Adjust the winners overlay for SX (classification table)**
- Update `renderCompetitionTop` to branch by discipline:
- For **DMO**, keep using `getDMProgressionData({ onlyFinals: true })` exactly as today.
- For **SX finals**, introduce a new helper (e.g. `getSXFinalClassification`) in [`src/renderer/utils/fileTranslation/SX.js`](src/renderer/utils/fileTranslation/SX.js) or [`src/renderer/utils/competition-utils.js`](src/renderer/utils/competition-utils.js) that:
- Produces a flat, sorted list of final results (1–N) using either `competition.getSortedByRank()` over `competitors` with `results_overall` or a dedicated SX ranking that respects `heat.results` and SX statuses (reusing `sortSXHeat`).
- Returns minimal objects `{ bib, name, result, rank }` for the overlay.
- Render this list in the bottom/right overlay block similarly to the current DMO winners view, matching as closely as practical the official SX bracket protocol screenshot (classification table for big/small finals).

- **Step 5 – Wire SX finals into the protocol builder UX**
- Confirm that the existing grid-enabled templates (those containing `type: 'grid'` blocks in `ProtocolDocument`) are already used for **DMO** results protocols and can be reused for SX when the active competition is an SX final.
- If needed, create or document a dedicated “SX Finals Bracket” template by saving a `ProtocolDocument` with a single `grid` block and appropriate header/footer; ensure no DMO-specific labels are hard-coded in the header.
- Verify that the Protocols page ([`src/renderer/pages/ProtocolsPage.vue`](src/renderer/pages/ProtocolsPage.vue)) correctly picks up the current competition, so that when an SX final competition is active, the same template automatically renders the SX grid instead of DMO.

- **Step 6 – Regression and UX checks**
- **DMO regression**:
- Print/export existing dual-moguls events that previously worked: check that pagination, vertical spacing, colours, and winners overlay are bit-for-bit (or visually) identical.
- Stress-test with maximum bracket size (128/64) to ensure the pairing-based pagination logic is unaffected by the SX changes.
- **SX finals validation**:
- Build small sample events mirroring your screenshots: multiple stages (1/8, 1/4, 1/2, big/small finals) with four competitors per heat and a mix of numeric places and statuses.
- Verify that the printed grid shows four-lane heats with correct names, colours, results, and that long names shrink gracefully.
- Check behaviour when some heats are incomplete (missing competitors/results) to ensure the grid degrades gracefully instead of throwing errors.
- **Edge cases**:
- Ensure non-final SX events (e.g. qualification) still use their existing protocol paths and that the grid block does not accidentally activate for non-final SX competitions.
- Confirm that protocols for non-DMO/SX disciplines (MO, AE, SS, etc.) are completely unaffected by the new grid logic.

### To-dos

- [ ] Add a `buildGridRaces(dataCtx)` helper in `ProtocolGrid.js` that normalises `competition.races` into a shared `{ id, title, runs[] }` shape for both DMO and SX finals and update `splitGridIntoPages` and `ProtocolGridBlock.render` to use it.
- [ ] Refactor `renderGridRun`/`renderRunCompetitor` in `ProtocolGrid.js` to branch between existing DMO two-lane rendering and new SX four-lane rendering, using `getCompetitorById` plus `heatColors`/`getHeatCompetitorColor` and `heats.results[idx]` for SX.
- [ ] Introduce an SX-specific final classification helper (e.g. `getSXFinalClassification`) and update `renderCompetitionTop` so DMO keeps using `getDMProgressionData` while SX finals show an appropriate ranking/classification table.
- [ ] Confirm or create a protocol builder template with a `grid` block suitable for both DMO and SX finals, and verify that `ProtocolsPage` previews/exports SX finals using the new grid without breaking legacy protocols.
- [ ] Run targeted manual tests on DMO and SX events (including maximal bracket sizes and incomplete heats) to validate pagination, layout, and results and to ensure no regressions in other disciplines’ protocols.