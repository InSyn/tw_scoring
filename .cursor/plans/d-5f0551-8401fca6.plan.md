<!-- 8401fca6-fc58-44ed-98a4-cfcffc953aa4 3daba3a7-eb74-4a25-9fa9-83b6287df161 -->
# DMO Grid Pagination – Robust Fix Plan (v2)

## 1. Restate Goals and Current Regression

- **Visual goal**: For DMO result grids, each protocol page’s `.protocol-grid` should:
  - Fill the available page content area vertically.
  - Split into multiple pages when there are too many runs to fit comfortably, instead of compressing runs.
  - Keep stage columns equal-height per page and visually similar to the legacy layout.
- **Technical goal**: Restore robust, measurement-driven pagination while preserving the new features:
  - Runtime-only `_gridLayout` metadata.
  - First-page-only winners overlay.
  - Independence from user-specified `height` when deciding pagination, with `height` treated as a *minimum visual height*.
- **Observed regression** (from latest screenshots):
  - The inner flex wrapper and stage columns now always match the page content height, so the grid visually fills the page.
  - However, as more runs are added, the grid tends to *compress* content rather than trigger pagination – the measured `fullHeight` no longer exceeds `availableHeight`, so `splitGridIntoPages` never activates.

## 2. Re-verify Measurement vs. Page Height

- **Key code paths**:
  - Page sizing and available height for content:
```46:70:src/renderer/classes/Protocol/ProtocolDocument.js
const contentHeight = pageSizes.height - pageSizes.top - pageSizes.bottom;
...
const totalHeaderHeight = headers.reduce((sum, block) => sum + measureBlockHeight(block, dataCtx, measuringContainer), 0);
const totalFooterHeight = footers.reduce((sum, block) => sum + measureBlockHeight(block, dataCtx, measuringContainer), 0);
const availableHeight = contentHeight - totalHeaderHeight - totalFooterHeight;
```

  - Grid pagination entry point:
```71:99:src/renderer/classes/Protocol/ProtocolDocument.js
const normalBlocks = this.blocks.filter((b) => b.type !== 'page-header' && b.type !== 'page-footer');
...
if (block instanceof ProtocolGridBlock) {
  if (currentPage.length > 0) { ... flush ... }
  const gridPages = splitGridIntoPages({ block, dataCtx, availableHeight, measuringContainer, maxPages: 4 });
  gridPages.forEach((gridBlock) => { paginatedPages.push([gridBlock]); });
}
```

  - Grid measurement helper and early-return logic:
```212:281:src/renderer/classes/Protocol/ProtocolGrid.js
const measureGridHeightIgnoringExplicitHeight = (sourceBlock, dataCtx, container) => {
  const measurementBlock = new ProtocolGridBlock({
    id: sourceBlock.id,
    type: sourceBlock.type,
    blockName: sourceBlock.blockName,
    styles: { ...sourceBlock.styles, height: 'auto' },
    onUpdate: sourceBlock.onUpdate,
  });
  measurementBlock.pageSegments = sourceBlock.pageSegments || null;
  return measureBlockHeight(measurementBlock, dataCtx, container);
};
...
const fullHeight = measureGridHeightIgnoringExplicitHeight(block, dataCtx, measuringContainer);
if (fullHeight <= availableHeight + tolerance) {
  // currently returns a single auto-height block with `_gridLayout`
  ...
}
```

- **Plan for verification**:
  - Temporarily (during implementation) add non-noisy `console.log` statements in `splitGridIntoPages` reporting `availableHeight`, `fullHeight`, and chosen `pagesCount` for representative events.
  - Cross-check against screenshots to ensure `fullHeight` genuinely grows with more runs and crosses `availableHeight` when pagination is expected.
  - Use this to confirm that any remaining “no pagination” behaviour is due to **content compression**, not measurement math.

## 3. Separate Measurement Layout from Paged Visual Layout

### 3.1. Restore Non-compressing Baseline for Measurement

- **Problem**: Some of the recent style changes risk letting the browser squeeze runs to keep the grid inside the page height, which hides the need for pagination.
- **Target baseline**:
  - Measurement DOM should reflect **natural content height**:
    - Stage runs container grows with runs; no forced fill of page height.
    - Individual run boxes have stable height determined by font size, paddings, and margins.
- **Concrete actions**:

  1. **Revert `stageRunsStyles.flex` to non-stretching baseline**:
```8:35:src/renderer/classes/Protocol/ProtocolGrid.js
stageRunsStyles: {
-  flex: '1 1 0',
+  flex: '0 0 auto',
   display: 'flex',
   flexDirection: 'column',
   alignItems: 'stretch',
   overflow: 'visible',
   fontSize: '1em',
   color: '#000000',
},
```

  1. **Keep run box base styles (padding, line-height, font sizes) as the unit of vertical measurement**, i.e. do *not* change them in ways that would significantly shrink intrinsic height.
  2. Ensure that `measureGridHeightIgnoringExplicitHeight` always uses this baseline (i.e. `_gridLayout` must be `null` for all measurement blocks, as is currently the case).

### 3.2. Apply Paged Layout Only After Pagination Has Been Decided

- **Goal**: Use `_gridLayout` to refine layout **after** segmentation, without affecting the heights that were used to decide where page breaks happen.
- **Concrete actions**:
  - In `renderGridStage`, compute `stageRunsComputedStyles` differently for paged vs. non-paged grids:
```402:413:src/renderer/classes/Protocol/ProtocolGrid.js
const hasPagedLayout = ctx._gridLayout && ctx._gridLayout.layoutMode === 'paged';
const stageRunsComputedStyles = {
  ...gridBlockStyles.stage.stageRunsStyles,
- justifyContent: isSemiFinalStage || isFinalStage ? 'center' : hasPagedLayout ? 'space-between' : 'flex-start',
+ flex: hasPagedLayout ? '1 1 0' : gridBlockStyles.stage.stageRunsStyles.flex,
+ height: hasPagedLayout ? '100%' : 'auto',
+ justifyContent: isSemiFinalStage || isFinalStage
+   ? 'center'
+   : hasPagedLayout
+   ? 'space-between'
+   : 'flex-start',
};
```

- Because `_gridLayout` is only set *after* measurement in `splitGridIntoPages`, these changes will:
  - Leave measurement unaffected (runs expand naturally with content).
  - In final rendered pages, allow runs to be distributed across the full stage height using flex behaviour and `space-between`.

## 4. Finalise `_gridLayout` Metadata & Height Semantics (Option A)

### 4.1. Rich metadata per page-block

- **Current behaviour**: `_gridLayout` only holds `layoutMode` and `slack`.
- **Required extension**:
  - For both single-page and multi-page grids, set:
```360:371:src/renderer/classes/Protocol/ProtocolGrid.js
subBlock._gridLayout = {
  layoutMode: 'paged',
  contentHeight,        // measured height of this grid segment
  targetHeight,         // desired visual height (<= availableHeight)
  slack,                // targetHeight - contentHeight, >= 0
  runsPerStage: null,   // to be filled in render()
  totalRuns: null,
  extraPerRun: null,    // derived from slack and totalRuns
};
```

- **Unsplit case**: when `fullHeight <= availableHeight + tolerance`, instead of returning the raw `block`, create a cloned `ProtocolGridBlock` with `_gridLayout` filled exactly the same way (contentHeight = `fullHeight`, targetHeight = `availableHeight`).

### 4.2. Implement Option A: `height` as minimum visual height

- **Desired semantics**:
  - Pagination is always driven by **content height with `height: auto`**.
  - A user-specified `styles.height` for the grid acts as a **minimum targetHeight**, clamped to the page’s content height.
- **Concrete actions**:

  1. Import `parseSizeUnitsToNumber` from `protocolTemplate-utils` into `ProtocolGrid.js` (or create a minimal local helper that wraps it).
  2. When constructing `_gridLayout` (both unsplit and split cases), compute:
```js
const minHeightPx = block.styles && block.styles.height
  ? parseSizeUnitsToNumber(block.styles.height)
  : null;
const unclampedTarget = Math.max(contentHeight, minHeightPx || 0);
const targetHeight = Math.min(availableHeight, unclampedTarget);
const slack = Math.max(0, targetHeight - contentHeight);
```

  1. Store `targetHeight` and `slack` in `_gridLayout`, but **do not** write them back into `styles.height`. The inner flex wrapper in `render()` already uses `layout.targetHeight` to set its own height.
  2. Refine the existing console warning for explicit heights to document this behaviour clearly for developers.

## 5. Use Slack to Drive Vertical Spacing, Not Compression

### 5.1. Compute runs-per-page in `render()`

- **Goal**: Use slack to add *extra* vertical spacing (top/bottom padding and/or inter-run gaps) without ever shrinking runs below their measured height.
- **Concrete actions in `ProtocolGridBlock.render`**:

  1. After validating `gridData.races`, and before building `renderedStages`, derive per-stage run counts for this page:
```161:178:src/renderer/classes/Protocol/ProtocolGrid.js
const layout = this._gridLayout || {};
const pageSegments = this.pageSegments || null;

if (Array.isArray(gridData.races)) {
  const runsPerStage = [];
  let totalRuns = 0;
  gridData.races.forEach((stage, index) => {
    if (!stage || !Array.isArray(stage.runs)) return;
    let count = stage.runs.length;
    if (pageSegments && pageSegments[index]) {
      const { start, end } = pageSegments[index];
      count = Math.max(0, Math.min(end, stage.runs.length) - start);
    }
    runsPerStage[index] = count;
    totalRuns += count;
  });

  if (layout && typeof layout === 'object') {
    layout.runsPerStage = runsPerStage;
    layout.totalRuns = totalRuns;
  }
}
```

  1. With `layout.slack` and `layout.totalRuns`, compute a safe per-run spacing budget:
```js
const totalRuns = layout.totalRuns || 0;
let extraPerRun = 0;
if (layout.slack > 0 && totalRuns > 0) {
  extraPerRun = Math.min(layout.slack / (totalRuns * 2), 24); // clamp to 24px
  layout.extraPerRun = extraPerRun;
}
```


### 5.2. Apply spacing in `renderGridRun`

- **Goal**: Replace the fragile `marginTop: 'auto'` / `marginBottom: 'auto'` behaviour with explicit, bounded margins derived from `extraPerRun`.
- **Concrete actions**:
```429:450:src/renderer/classes/Protocol/ProtocolGrid.js
const renderGridRun = (dataCtx, { stage, isEvenStage, isSemiFinalStage, isFinalStage, run }, ctx) => {
  ...
  const hasPagedLayout = ctx._gridLayout && ctx._gridLayout.layoutMode === 'paged';
  const extraPerRun = hasPagedLayout && typeof ctx._gridLayout.extraPerRun === 'number'
    ? ctx._gridLayout.extraPerRun
    : 0;

  const stageRunComputedStyles = {
    ...gridBlockStyles.run.stageRunStyles,
  };

  if (hasPagedLayout) {
    const gap = `${extraPerRun / 2}px`;
    stageRunComputedStyles.marginTop = isFinalStage || isSemiFinalStage ? gap : gap;
    stageRunComputedStyles.marginBottom = isFinalStage || isSemiFinalStage ? gap : gap;
  } else {
    stageRunComputedStyles.marginTop = isFinalStage ? '0' : 'auto';
    stageRunComputedStyles.marginBottom = isFinalStage ? '2rem' : 'auto';
  }
  ...
};
```

- This ensures that:
  - On paged grids, we **only add** small, controlled spacing based on slack; runs keep their measured height.
  - On non-paged grids (where `_gridLayout` is absent), the legacy “auto margins” behaviour is preserved.

## 6. Preserve Winners Overlay and Relative Positioning

- **Goal**: Ensure the winners overlay remains first-page-only and is positioned relative to the grid area even with the new inner flex wrapper.
- **Checks and adjustments**:
  - Confirm `ProtocolDocument.render()` still forwards `{ page: pageIdx + 1, totalPages }` into `renderPage`:
```227:233:src/renderer/classes/Protocol/ProtocolDocument.js
return this.paginatedPages
  .map((_, pageIdx, pagesArr) => this.renderPage(pageIdx, { ...dataCtx, page: pageIdx + 1, totalPages: pagesArr.length }))
  .join('');
```

  - Keep the first-page-only guard in `renderCompetitionTop`:
```536:541:src/renderer/classes/Protocol/ProtocolGrid.js
if (dataCtx && typeof dataCtx.page === 'number' && dataCtx.page > 1) {
  return '';
}
```

  - Verify that `competitionTopStyles.wrapper.position = 'absolute'` still anchors correctly when inside the new inner flex wrapper. If necessary, move the overlay container inside the inner wrapper so that its `bottom/right` offsets are measured against the grid content height (`targetHeight`).

## 7. Testing & Verification Steps

### 7.1. Functional pagination tests

- **DMO brackets of varying sizes** (16, 32, 64 competitors):
  - For each, generate DMO result-grid protocols and observe:
    - With generous page height: grid stays on one page and visually fills content area (via slack-based spacing), with readable spacing between runs.
    - After decreasing page height or increasing runs:
      - `splitGridIntoPages` should report `fullHeight > availableHeight`, choose `pagesCount >= 2`, and create multiple `ProtocolGridBlock` segments.
      - Each page should show a subset of runs per stage (according to `pageSegments`), with columns equal-height and runs spread vertically.

### 7.2. Explicit grid height scenarios

- **Templates with `grid` height set to** `auto`, `600px`, `900px`, `1200px`:
  - Confirm pagination boundaries depend **only** on content height, not the explicit `height` value.
  - Visually, verify that:
    - `height` acts as a minimum: grids are never shorter than requested (unless the page content area is smaller).
    - Grids never exceed the page content area due to `targetHeight` clamping.

### 7.3. Regression checks

- **Non-grid templates** (tables and simple blocks):
  - Re-open existing result/start-list templates and confirm:
    - `TableBlock.splitForPagesWithLeftover` behaviour is unchanged.
    - Paginated tables still break at the same rows.
    - No unexpected shifts in headers/footers or page counts.

- **PDF export**:
  - Export multi-page DMO grids and visually compare against the legacy reference (`_temp-data_/Скриншот 25-11-2025 002240.jpg`):
    - Columns should occupy the full content height.
    - Runs should be evenly and comfortably spaced.
    - Page count and run distribution should align with on-screen preview.